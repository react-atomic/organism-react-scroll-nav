{"version":3,"file":"main.c56e586d1b57262f37a0.hot-update.js","sources":["webpack:///./build/es/src/stores/scrollStore.js"],"sourcesContent":["import _objectSpread from \"reshow-runtime/es/helpers/objectSpread2\";\nimport _assertThisInitialized from \"reshow-runtime/es/helpers/assertThisInitialized\";\nimport _inheritsLoose from \"reshow-runtime/es/helpers/inheritsLoose\";\nimport _defineProperty from \"reshow-runtime/es/helpers/defineProperty\";\nimport { Set, Map } from 'immutable';\nimport { ReduceStore } from 'reshow-flux';\nimport getScrollInfo from 'get-scroll-info';\nimport { isOnScreen } from 'get-window-offset';\nimport getOffset from 'getoffset';\nimport get, { toJS } from 'get-object-value';\nimport dispatcher, { scrollDispatch } from '../scrollDispatcher';\nimport testForPassiveScroll from '../testForPassiveScroll';\nvar incNum = 0;\nvar DEFAULT_SCROLL_ID = -1;\nvar keys = Object.keys;\n\nvar scrollStore = /*#__PURE__*/function (_ReduceStore) {\n  _inheritsLoose(scrollStore, _ReduceStore);\n\n  function scrollStore() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _ReduceStore.call.apply(_ReduceStore, [this].concat(args)) || this;\n\n    _defineProperty(_assertThisInitialized(_this), \"storeName\", 'delayScroll');\n\n    _defineProperty(_assertThisInitialized(_this), \"isInitEvent\", {});\n\n    _defineProperty(_assertThisInitialized(_this), \"isInitResizeEvent\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"spys\", {});\n\n    return _this;\n  }\n\n  var _proto = scrollStore.prototype;\n\n  _proto.getInitialState = function getInitialState() {\n    this.trigger = this.triggerScroll.bind(this);\n    this.arrNode = Map();\n    this.margins = Set();\n    this.scrollMonitor = this.runScrollMonitor.bind(this);\n    this.bindHandleResize = this.handleResize.bind(this);\n    return Map({\n      scrollDelay: 50,\n      scrollMargin: 0\n    });\n  };\n\n  _proto.initResizeEvent = function initResizeEvent() {\n    if ('undefined' !== typeof window) {\n      this.isInitResizeEvent = true;\n      var win = window;\n\n      if (win.addEventListener) {\n        win.addEventListener('resize', this.bindHandleResize);\n      } else {\n        win.attachEvent('onresize', this.bindHandleResize);\n      }\n    }\n  };\n\n  _proto.initEvent = function initEvent(el) {\n    var _this2 = this;\n\n    if ('undefined' !== typeof el) {\n      var self = this;\n\n      if (el.addEventListener) {\n        var supportsPassive = testForPassiveScroll();\n        el.addEventListener('scroll', self.scrollMonitor, supportsPassive ? {\n          passive: true\n        } : false);\n      } else {\n        el.attachEvent('onscroll', self.scrollMonitor);\n      }\n\n      setTimeout(function () {\n        _this2.trigger(el); //for lazy content\n\n\n        setTimeout(function () {\n          return _this2.trigger(el);\n        }, 777);\n      });\n\n      if (!self.isInitResizeEvent) {\n        self.initResizeEvent();\n      }\n    }\n  };\n\n  _proto.removeEvent = function removeEvent(el) {\n    el.removeEventListener('scroll', this.scrollMonitor);\n  };\n\n  _proto.handleResize = function handleResize() {\n    var _this3 = this;\n\n    keys(this.spys).forEach(function (scrollId) {\n      return _this3.runScrollMonitor({\n        target: {\n          id: scrollId\n        }\n      });\n    });\n  };\n\n  _proto.runScrollMonitor = function runScrollMonitor(e) {\n    var _this4 = this;\n\n    clearTimeout(this._scrollTimeout);\n    var self = this;\n    var delay = self.getState().get('scrollDelay');\n    self._scrollTimeout = setTimeout(function () {\n      return _this4.trigger(e && e.target);\n    }, delay);\n  };\n\n  _proto.triggerScroll = function triggerScroll(scrollNode) {\n    var scrollId = get(scrollNode, ['id']) || DEFAULT_SCROLL_ID;\n    var defaultMargin = this.getState().get('scrollMargin');\n    var actives = {\n      mdefault: null\n    };\n    var offsetCache = {};\n    var arrMonitorScroll = [];\n    var scroll = getScrollInfo();\n    var scrollTop = scroll.top + defaultMargin;\n    var margin;\n    (this.spys[scrollId] || []).forEach(function (node) {\n      var nodeEl = node.getOffsetEl();\n\n      var _get = get(node, ['props'], {}),\n          monitorScroll = _get.monitorScroll,\n          scrollMargin = _get.scrollMargin;\n\n      var pos = getOffset(nodeEl);\n\n      if (monitorScroll) {\n        if (scrollTop >= pos.top && scrollTop < pos.bottom) {\n          actives.mdefault = node.id;\n        }\n\n        arrMonitorScroll.push(node);\n      }\n\n      margin = scrollMargin ? scrollMargin : defaultMargin;\n      pos = isOnScreen(pos, scroll, margin);\n      offsetCache[node.id] = pos;\n    });\n    this.margins.forEach(function (margin) {\n      scrollTop = scroll.top + margin;\n      actives['m' + margin] = null;\n      arrMonitorScroll.every(function (node) {\n        var pos = offsetCache[node.id];\n\n        if (scrollTop >= pos.top && scrollTop < pos.bottom - 1) {\n          actives['m' + margin] = node.id;\n          return false;\n        }\n\n        return true;\n      });\n    });\n    this.margins = this.margins.clear();\n    scrollDispatch(_objectSpread(_objectSpread({}, actives), {}, {\n      nodes: offsetCache,\n      scroll: scroll,\n      storeName: this.storeName\n    }));\n  };\n\n  _proto.getNode = function getNode(id) {\n    if (this.arrMap && this.arrMap.get) {\n      return toJS(this.arrMap.get(id));\n    }\n  };\n\n  _proto.getOffset = function getOffset(id, callName) {\n    var nodes = this.getMap('nodes');\n    return nodes[id];\n  };\n\n  _proto.hasAttach = function hasAttach(node) {\n    var attachToId = this.getAttachToId(node);\n\n    if (this.spys[attachToId] && this.spys[attachToId].has(node)) {\n      return attachToId;\n    } else {\n      return false;\n    }\n  };\n\n  _proto.getNodeId = function getNodeId(node) {\n    if (!node.id) {\n      if (node.props && node.props.id) {\n        node.id = node.props.id;\n      } else {\n        node.id = 'spy-' + incNum;\n        incNum++;\n      }\n    }\n\n    return node.id;\n  };\n\n  _proto.getAttachToId = function getAttachToId(node) {\n    var attachTo = get(node, ['props', 'attachTo']);\n    var attachToId;\n\n    if (attachTo) {\n      node.attachTo = attachTo;\n      attachToId = this.getNodeId(attachTo);\n    } else {\n      if ('undefined' !== typeof window) {\n        node.attachTo = window;\n      }\n\n      attachToId = DEFAULT_SCROLL_ID;\n    }\n\n    return attachToId;\n  };\n\n  _proto.attach = function attach(node) {\n    console.warn({\n      node: node\n    });\n    var nodeId = this.getNodeId(node);\n    var attachToId = this.getAttachToId(node);\n\n    if (!this.spys[attachToId]) {\n      this.spys[attachToId] = Set().add(node);\n    } else {\n      this.spys[attachToId] = this.spys[attachToId].add(node);\n    }\n\n    this.arrNode = this.arrNode.set(nodeId, node);\n\n    if (!this.isInitEvent[attachToId]) {\n      this.isInitEvent[attachToId] = true;\n      this.initEvent(node.attachTo);\n    }\n\n    return nodeId;\n  };\n\n  _proto.detach = function detach(node) {\n    var attachToId = this.hasAttach(node);\n\n    if (attachToId) {\n      this.spys[attachToId] = this.spys[attachToId].remove(node);\n      this.arrNode = this.arrNode[\"delete\"](node.id);\n\n      if (!this.spys[attachToId].size) {\n        this.removeEvent(node.attachTo);\n        delete this.spys[attachToId];\n        this.isInitEvent[attachToId] = false;\n      }\n    }\n  };\n\n  _proto.addMargin = function addMargin(num) {\n    this.margins = this.margins.add(num);\n  };\n\n  _proto.deleteMargin = function deleteMargin(num) {\n    this.margins = this.margins.remove(num);\n  };\n\n  _proto.reduce = function reduce(state, action) {\n    var storeName = get(action, ['storeName'], 'delayScroll');\n\n    if (storeName === this.storeName) {\n      return state.merge(action);\n    } else {\n      return state;\n    }\n  };\n\n  return scrollStore;\n}(ReduceStore);\n\nexport default new scrollStore(dispatcher);\nexport { scrollStore };"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}